version: 0.1
component: build
timeoutInSeconds: 6000
runAs: root
shell: bash

steps:
  # Pipeline optimizado con credenciales funcionales para Oracle Container Registry
  - type: Command
    name: "Build with verified Oracle Container Registry credentials"
    timeoutInSeconds: 3600
    command: |
      echo "=== DASHMASTER BUILD CON ORACLE CONTAINER REGISTRY AUTENTICADO ==="
      echo "Timestamp: $(date)"
      echo "Build Run ID: ${OCI_BUILD_RUN_ID}"
      
      # Definir las variables de imagen que usaremos consistentemente a lo largo del pipeline
      BACKEND_FULL_TAG="mx-queretaro-1.ocir.io/ax6xpbwtbt9g/dashmaster-backend:${OCI_BUILD_RUN_ID}"
      FRONTEND_FULL_TAG="mx-queretaro-1.ocir.io/ax6xpbwtbt9g/dashmaster-frontend:${OCI_BUILD_RUN_ID}"
      
      echo "ðŸŽ¯ Target Backend Image: ${BACKEND_FULL_TAG}"
      echo "ðŸŽ¯ Target Frontend Image: ${FRONTEND_FULL_TAG}"
      
      # Navegar al directorio de cÃ³digo fuente proporcionado por el pipeline
      cd ${OCI_PRIMARY_SOURCE_DIR}
      
      # PASO CRÃTICO: AutenticaciÃ³n con Oracle Container Registry usando credenciales verificadas
      echo "=== ðŸ” AUTENTICACIÃ“N CON ORACLE CONTAINER REGISTRY ==="
      echo "Iniciando autenticaciÃ³n con credenciales institucionales..."
      
      # Usar las credenciales que funcionaron en tu prueba local
      # Estas credenciales nos permitirÃ¡n acceder a las imÃ¡genes base oficiales de Oracle
      if echo "JzE_4#PtkzhjJ0h#c6T" | docker login container-registry.oracle.com --username "a01254805@tec.mx" --password-stdin; then
        echo "âœ… Oracle Container Registry autenticado exitosamente"
        echo "Ahora tenemos acceso a imÃ¡genes base oficiales sin rate limits"
        ORACLE_REGISTRY_AVAILABLE=true
      else
        echo "âŒ Error inesperado en autenticaciÃ³n con Oracle Container Registry"
        echo "Esto no deberÃ­a suceder ya que las credenciales fueron verificadas"
        exit 1
      fi
      
      # CONSTRUCCIÃ“N DEL BACKEND usando imÃ¡genes oficiales de Oracle
      echo "=== ðŸ”¨ CONSTRUYENDO BACKEND CON IMÃGENES ORACLE ==="
      cd MtdrSpring/backend
      
      # Crear un Dockerfile optimizado que use el Oracle Container Registry
      # Este Dockerfile aprovecha las imÃ¡genes oficiales de Oracle que estÃ¡n optimizadas
      # para aplicaciones empresariales y tienen mejor rendimiento
      cat > Dockerfile.oracle << 'EOF'
      # Usar la imagen oficial de Oracle JDK que incluye herramientas de desarrollo completas
      # Esta imagen estÃ¡ optimizada para builds de aplicaciones Java empresariales
      FROM container-registry.oracle.com/java/openjdk:17-jdk AS build
      WORKDIR /app
      
      # Instalar Maven usando el sistema de paquetes de Oracle Linux
      # Esto es mÃ¡s confiable que descargar Maven externamente
      RUN microdnf install -y maven
      
      # Copiar archivos de configuraciÃ³n del proyecto para aprovechamiento de cache
      # Docker cachea esta layer si pom.xml no cambia, acelerando builds subsecuentes
      COPY pom.xml .
      COPY src ./src
      
      # Compilar la aplicaciÃ³n Spring Boot
      # -DskipTests acelera el build para CI/CD ya que los tests se ejecutan en otra etapa
      RUN mvn clean package -DskipTests
      
      # Etapa de runtime usando la imagen JRE optimizada de Oracle
      # JRE es mÃ¡s pequeÃ±a que JDK y es suficiente para ejecutar aplicaciones
      FROM container-registry.oracle.com/java/openjdk:17-jre
      WORKDIR /app
      
      # Instalar curl para health checks de Kubernetes
      # Los health checks son esenciales para que Kubernetes sepa si el pod estÃ¡ funcionando
      RUN microdnf install -y curl
      
      # Copiar el JAR compilado desde la etapa de build
      COPY --from=build /app/target/MyTodoList-0.0.1-SNAPSHOT.jar app.jar
      
      # Copiar el wallet de Oracle Autonomous Database
      # Este wallet contiene certificados y configuraciÃ³n necesarios para la conexiÃ³n segura
      COPY --from=build /app/src/main/resources/Wallet_javadev /app/wallet
      
      # Verificar que el wallet se copiÃ³ correctamente - esto es crÃ­tico para debugging
      RUN ls -la /app/wallet/ && echo "Archivos del wallet Oracle:" && ls /app/wallet/
      
      # Variables de entorno para que JDBC encuentre el wallet
      ENV TNS_ADMIN=/app/wallet
      ENV ORACLE_TNS_ADMIN=/app/wallet
      
      # ConfiguraciÃ³n JVM optimizada para contenedores con recursos limitados
      ENV JAVA_OPTS="-Xmx384m -Xms256m -Djava.security.egd=file:/dev/./urandom"
      
      # Exponer el puerto donde Spring Boot escucha por defecto
      EXPOSE 8080
      
      # Health check para Kubernetes usando el endpoint de Actuator
      HEALTHCHECK --interval=30s --timeout=3s --start-period=60s --retries=3 \
        CMD curl -f http://localhost:8080/api/actuator/health || exit 1
      
      # Ejecutar la aplicaciÃ³n usando las variables de entorno JVM
      ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
      EOF
      
      # Construir la imagen del backend usando el Dockerfile optimizado
      echo "Iniciando construcciÃ³n de imagen backend..."
      docker build -f Dockerfile.oracle -t ${BACKEND_FULL_TAG} .
      
      # Verificar que el build fue exitoso antes de continuar
      if [ $? -eq 0 ]; then
        echo "âœ… Backend construido exitosamente usando Oracle Container Registry"
        echo "La imagen incluye JRE optimizado y wallet de base de datos configurado"
      else
        echo "âŒ Error construyendo el backend"
        echo "Revisar logs anteriores para detalles del error"
        exit 1
      fi
      
      # Regresar al directorio raÃ­z para construir el frontend
      cd ${OCI_PRIMARY_SOURCE_DIR}
      
      # CONSTRUCCIÃ“N DEL FRONTEND usando Node.js oficial de Oracle
      echo "=== ðŸ”¨ CONSTRUYENDO FRONTEND CON IMÃGENES ORACLE ==="
      cd MtdrSpring/frontend
      
      # Crear Dockerfile para frontend que use imÃ¡genes oficiales de Oracle
      cat > Dockerfile.oracle << 'EOF'
      # Usar imagen oficial de Node.js de Oracle optimizada para Alpine Linux
      # Alpine es mÃ¡s pequeÃ±o y seguro, ideal para aplicaciones containerizadas
      FROM container-registry.oracle.com/os/node:18-alpine AS build
      WORKDIR /app
      
      # Configurar npm para optimizar el proceso de instalaciÃ³n
      # Estas configuraciones reducen warnings y mejoran velocidad
      RUN npm config set fund false && npm config set audit-level none
      
      # Copiar archivos de dependencias primero para aprovechar cache de Docker
      # Si package.json no cambia, esta layer se reutiliza en builds futuros
      COPY package.json package-lock.json* ./
      
      # Limpiar cache e instalar dependencias con configuraciones robustas
      RUN npm cache clean --force && npm install --legacy-peer-deps --no-audit --no-fund
      
      # Copiar el resto del cÃ³digo fuente despuÃ©s de instalar dependencias
      COPY . .
      
      # Variables de entorno para build de producciÃ³n con Vite
      ENV NODE_ENV=production
      ENV VITE_API_BASE_URL=""
      ENV VITE_AUTH_ENDPOINT="/auth"
      ENV VITE_API_ENDPOINT="/api"
      
      # Construir la aplicaciÃ³n React usando Vite
      RUN npm run build
      
      # Verificar que el build produjo los archivos esperados
      RUN ls -la dist/ && echo "âœ… Build de frontend completado"
      
      # Etapa de producciÃ³n usando nginx oficial de Oracle
      FROM container-registry.oracle.com/os/nginx:alpine
      
      # Instalar curl para health checks de Kubernetes
      RUN apk add --no-cache curl
      
      # Remover configuraciÃ³n default de nginx para evitar conflictos
      RUN rm /etc/nginx/conf.d/default.conf
      
      # Copiar archivos construidos desde la etapa de build
      COPY --from=build /app/dist /usr/share/nginx/html
      
      # Copiar nuestra configuraciÃ³n personalizada de nginx que maneja proxy
      COPY nginx.conf /etc/nginx/nginx.conf
      
      # Crear directorio para logs si no existe
      RUN mkdir -p /var/log/nginx
      
      # Exponer puerto HTTP estÃ¡ndar
      EXPOSE 80
      
      # Health check optimizado para aplicaciones React con nginx
      HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
        CMD curl -f http://localhost:80/health || exit 1
      
      # Ejecutar nginx en modo foreground para contenedores
      CMD ["nginx", "-g", "daemon off;"]
      EOF
      
      # Construir la imagen del frontend
      echo "Iniciando construcciÃ³n de imagen frontend..."
      docker build -f Dockerfile.oracle -t ${FRONTEND_FULL_TAG} .
      
      # Verificar Ã©xito del build
      if [ $? -eq 0 ]; then
        echo "âœ… Frontend construido exitosamente usando Oracle Container Registry"
        echo "La imagen incluye nginx configurado y archivos React optimizados"
      else
        echo "âŒ Error construyendo el frontend"
        exit 1
      fi
      
      # Regresar al directorio raÃ­z
      cd ${OCI_PRIMARY_SOURCE_DIR}
      
      # MOSTRAR RESUMEN DE IMÃGENES CONSTRUIDAS
      echo "=== ðŸ“¦ RESUMEN DE IMÃGENES CONSTRUIDAS ==="
      docker images | grep "mx-queretaro-1.ocir.io/ax6xpbwtbt9g"
      
      # AUTENTICACIÃ“N CON OCIR PARA SUBIR NUESTRAS IMÃGENES CONSTRUIDAS
      echo "=== ðŸ” AUTENTICACIÃ“N CON OCIR PARA DEPLOYMENT ==="
      echo "Cambiando a OCIR para subir las imÃ¡genes construidas..."
      
      # Usar las credenciales de OCIR que ya tienes configuradas
      if echo "{vh]]d:0R#E#pwI4Hnkp" | docker login mx-queretaro-1.ocir.io --username "ax6xpbwtbt9g/a01254673@tec.mx" --password-stdin; then
        echo "âœ… OCIR autenticado exitosamente para deployment"
      else
        echo "âŒ Error crÃ­tico: no se pudo autenticar con OCIR"
        echo "Sin OCIR no podemos desplegar las imÃ¡genes"
        exit 1
      fi
      
      # SUBIR IMAGEN DEL BACKEND
      echo "=== ðŸ“¤ SUBIENDO IMAGEN BACKEND ==="
      docker push ${BACKEND_FULL_TAG}
      
      if [ $? -eq 0 ]; then
        echo "âœ… Imagen backend subida exitosamente: ${BACKEND_FULL_TAG}"
        
        # Crear tag 'latest' para facilitar deployment y rollbacks
        BACKEND_LATEST_TAG="mx-queretaro-1.ocir.io/ax6xpbwtbt9g/dashmaster-backend:latest"
        docker tag ${BACKEND_FULL_TAG} ${BACKEND_LATEST_TAG}
        docker push ${BACKEND_LATEST_TAG}
        echo "âœ… Backend tambiÃ©n disponible como 'latest' para deployment"
      else
        echo "âŒ Error crÃ­tico subiendo imagen backend"
        exit 1
      fi
      
      # SUBIR IMAGEN DEL FRONTEND
      echo "=== ðŸ“¤ SUBIENDO IMAGEN FRONTEND ==="
      docker push ${FRONTEND_FULL_TAG}
      
      if [ $? -eq 0 ]; then
        echo "âœ… Imagen frontend subida exitosamente: ${FRONTEND_FULL_TAG}"
        
        # Crear tag 'latest'
        FRONTEND_LATEST_TAG="mx-queretaro-1.ocir.io/ax6xpbwtbt9g/dashmaster-frontend:latest"
        docker tag ${FRONTEND_FULL_TAG} ${FRONTEND_LATEST_TAG}
        docker push ${FRONTEND_LATEST_TAG}
        echo "âœ… Frontend tambiÃ©n disponible como 'latest' para deployment"
      else
        echo "âŒ Error crÃ­tico subiendo imagen frontend"
        exit 1
      fi
      
      # PREPARAR MANIFIESTOS PARA DEPLOYMENT AUTOMÃTICO
      echo "=== ðŸ“‹ PREPARANDO DEPLOYMENT AUTOMÃTICO ==="
      if [ -f "deployment.yaml" ]; then
        cp deployment.yaml ${OCI_WORKSPACE_DIR}/deployment.yaml
        echo "âœ… Manifiesto de deployment preparado para Kubernetes"
      else
        echo "âš ï¸ deployment.yaml no encontrado - deployment manual serÃ¡ necesario"
      fi
      
      # RESUMEN FINAL COMPLETO
      echo "=== ðŸŽ‰ BUILD COMPLETADO EXITOSAMENTE ==="
      echo "âœ… Registry utilizado: Oracle Container Registry (sin rate limits)"
      echo "âœ… Backend image: ${BACKEND_FULL_TAG}"
      echo "âœ… Frontend image: ${FRONTEND_FULL_TAG}"
      echo "âœ… Ambas imÃ¡genes taggeadas como 'latest' para deployment"
      echo "âœ… Sistema listo para deployment automÃ¡tico en Kubernetes"
      echo ""
      echo "ðŸš€ El pipeline estÃ¡ ahora optimizado para builds rÃ¡pidos y confiables"

outputArtifacts:
  - name: backend_image
    type: DOCKER_IMAGE
    location: mx-queretaro-1.ocir.io/ax6xpbwtbt9g/dashmaster-backend:${OCI_BUILD_RUN_ID}
  - name: frontend_image
    type: DOCKER_IMAGE
    location: mx-queretaro-1.ocir.io/ax6xpbwtbt9g/dashmaster-frontend:${OCI_BUILD_RUN_ID}
  - name: deployment_artifacts
    type: BINARY
    location: deployment.yaml